use ark_bls12_381::{Fr, G2Projective};
use ark_std::{collections::BTreeMap, vec::Vec};
use zeroize::Zeroize;

use crate::addr::Address;
use crate::cipher::Error as CipherError;
use crate::keys::{Keypair, PublicKey, SecretKey};
use crate::poly::{self, InterpolationError};
use crate::share::Error as ShareError;
use crate::share::PublicShare;

#[derive(Debug, displaydoc::Display)]
#[cfg_attr(feature = "std", derive(thiserror::Error))]
pub enum Error {
    /// Invalid share vector length {0}
    InvalidShareVectorLength(usize),
    /// Invalid number of participants {0}
    InvalidParticipantsLength(usize),
    /// Index {0} is out of bounds
    InvalidIndex(usize),
    /// Invalid shares collected from participant {0}
    InvalidShares(Address),
    /// Shares map is full
    SharesMapFull,
    /// Our index not found
    OurIndexNotFound,
    /// Our share's keypair is invalid.
    InvalidShareKeypair,
    /// Participant {0} already provided shares
    SharesAlreadyProvided(Address),
    /// Interpolation error
    Interpolation(#[cfg_attr(feature = "std", from, source)] InterpolationError),
    /// Error during encryption or decryption
    Cipher(#[cfg_attr(feature = "std", from, source)] CipherError),
    /// Error during share generation
    Share(#[cfg_attr(feature = "std", from, source)] ShareError),
}

#[cfg(not(feature = "std"))]
impl From<CipherError> for Error {
    fn from(e: CipherError) -> Self {
        Self::Cipher(e)
    }
}

#[cfg(not(feature = "std"))]
impl From<ShareError> for Error {
    fn from(e: ShareError) -> Self {
        Self::Share(e)
    }
}

#[cfg(not(feature = "std"))]
impl From<InterpolationError> for Error {
    fn from(e: InterpolationError) -> Self {
        Self::Interpolation(e)
    }
}

/// Map accumulating all shares generated by individual participants. It can be
/// thought of as a public share matrix where each row consists of shares
/// generated by a single participant to other participants (and themselves).
/// Thus each column consists of shares generated for a single participant by
/// other participants.
///
/// It also contains the total number of participants which is used to check
/// that only valid length public share vectors are inserted in the map.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SharesMap {
    inner: BTreeMap<Address, Vec<PublicShare>>,
    share_vec_len: usize,
}

impl SharesMap {
    pub fn new(share_vec_len: usize) -> Self {
        Self { inner: BTreeMap::new(), share_vec_len }
    }

    pub fn map(&self) -> &BTreeMap<Address, Vec<PublicShare>> {
        &self.inner
    }

    pub fn insert(&mut self, address: Address, share_vec: Vec<PublicShare>) -> Result<(), Error> {
        if share_vec.len() != self.share_vec_len {
            return Err(Error::InvalidShareVectorLength(share_vec.len()));
        } else if self.inner.len() >= self.share_vec_len {
            return Err(Error::SharesMapFull);
        }

        if self.inner.get(&address).is_some() {
            Err(Error::SharesAlreadyProvided(address))
        } else {
            self.inner.insert(address, share_vec);
            Ok(())
        }
    }

    fn interpolated_shvks(&self, id_scalars: &[Fr]) -> Result<Vec<G2Projective>, Error> {
        let mut interpolated_shvks = Vec::<G2Projective>::with_capacity(self.share_vec_len);
        for i in 0..self.share_vec_len {
            let shvks = self
                .inner
                .values()
                .map(|share_vec| share_vec[i].vk.into_projective())
                .collect::<Vec<_>>();

            let poly = poly::interpolate(&id_scalars, &shvks)?;
            interpolated_shvks.push(poly[0]);
        }

        Ok(interpolated_shvks)
    }

    fn decrypted_shsks(
        &self,
        self_index: usize,
        self_address_bytes: &[u8; 32],
        self_privkey: SecretKey,
    ) -> Result<Vec<Fr>, Error> {
        if self_index >= self.share_vec_len {
            return Err(Error::InvalidIndex(self_index));
        }

        let mut decrypted_shares_for_self = Vec::<Fr>::with_capacity(self.inner.len());
        for shares in self.inner.values() {
            let res = shares[self_index].esh.decrypt(self_address_bytes, self_privkey)?;
            decrypted_shares_for_self.push(res);
        }

        Ok(decrypted_shares_for_self)
    }

    fn verify_shares(&self, participants: &BTreeMap<Address, PublicKey>) -> Result<(), Error> {
        for share_vec in self.inner.values() {
            for (address, share) in participants.keys().zip(share_vec) {
                if share.esh.verify(address.as_bytes(), share.vk).is_err() {
                    return Err(Error::InvalidShares(*address));
                }
            }
        }
        Ok(())
    }

    pub fn recover_keys(
        self,
        self_address: &Address,
        self_privkey: SecretKey,
        participants: &BTreeMap<Address, PublicKey>,
    ) -> Result<(PublicKey, Keypair), Error> {
        if participants.len() != self.share_vec_len {
            return Err(Error::InvalidParticipantsLength(participants.len()));
        }

        self.verify_shares(participants)?;

        let share_id_scalars = self.inner.keys().map(|address| address.as_scalar()).collect::<Vec<_>>();
        let mut self_index = None;
        let all_id_scalars = participants
            .keys()
            .enumerate()
            .map(|(i, address)| {
                if address == self_address {
                    self_index = Some(i);
                }
                address.as_scalar()
            })
            .collect::<Vec<Fr>>();

        let self_index = self_index.ok_or_else(|| Error::OurIndexNotFound)?;
        let interpolated_shvks = self.interpolated_shvks(&share_id_scalars)?;
        let mut decrypted_shsks = self.decrypted_shsks(self_index, self_address.as_bytes(), self_privkey)?;

        let mut shsk_poly = poly::interpolate(&share_id_scalars, &decrypted_shsks)?;
        let shsk = shsk_poly[0];
        shsk_poly.zeroize();
        decrypted_shsks.zeroize();

        let gshvk_poly = poly::interpolate(&all_id_scalars, &interpolated_shvks)?;
        let gvk = gshvk_poly[0].into();
        let shsk = shsk.into();
        let share_keypair = Keypair::from_sk(shsk);
        let shpk = interpolated_shvks[self_index].into();
        if share_keypair.pk() != shpk {
            return Err(Error::InvalidShareKeypair);
        }

        Ok((gvk, share_keypair))
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::share::EncryptedShare;
    use ark_bls12_381::{G1Affine, G2Affine};
    use ark_ec::AffineRepr;
    use ark_poly::{univariate::DensePolynomial, DenseUVPolynomial, Polynomial};
    use ark_std::rand;
    use ark_std::Zero;
    use poly::DenseGPolynomial;

    #[rustfmt::skip]
    const ADDRESSES: &[Address; 4] = &[
        Address::new([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        Address::new([2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        Address::new([3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        Address::new([4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
    ];

    const THRESHOLD: usize = 3;
    const START: usize = 2;

    // everything will be encrypted with this keypair
    fn test_keypair() -> Keypair {
        Keypair::from_sk(SecretKey::from(Fr::from(2)))
    }

    fn test_polynomials(start: usize) -> (DensePolynomial<Fr>, DenseGPolynomial<G2Projective>) {
        let mut scalars = Vec::<Fr>::with_capacity(THRESHOLD);
        let mut points = Vec::<G2Projective>::with_capacity(THRESHOLD);
        for i in 0..THRESHOLD {
            let scalar = Fr::from((start + i) as u64);
            let point = G2Affine::generator() * scalar;
            scalars.push(scalar);
            points.push(point);
        }
        (DensePolynomial::from_coefficients_vec(scalars), DenseGPolynomial::from_coefficients_vec(points))
    }

    fn test_participants() -> BTreeMap<Address, PublicKey> {
        ADDRESSES
            .iter()
            .map(|address| (*address, G2Affine::generator().into()))
            .collect()
    }

    // NOTE test map will look like this: These are the secret shares generated
    // by each node for themselves and others (by evaluating the polynomial at
    // the node identifier, i.e. the address as a scalar). The test map
    // actually consists of the public parts of these scalars, i.e. the
    // respective point on the curve and the secret share encrypted by the
    // recipient's public key
    //
    // Address        Polynomial  Node 1 shares  Node 2 shares  Node 3 shares  Node 4 shares
    //       1     2 + 3x + 4x^2              9             24             47             78
    //       2     5 + 6x + 7x^2             18             45             86            141
    //       3    8 + 9x + 10x^2             27             66            125            204
    //       4  11 + 12x + 13x^2             36             87            164            267
    fn build_test_map(keypair: &Keypair) -> SharesMap {
        let mut rng = rand::rngs::OsRng;
        let mut shares_map = SharesMap::new(ADDRESSES.len());

        for (i, address) in ADDRESSES.iter().enumerate() {
            let (private_poly, public_poly) = test_polynomials(START + i * THRESHOLD);
            let shares = ADDRESSES
                .iter()
                .map(|address| {
                    let public_share = public_poly.evaluate(&address.as_scalar());
                    let private_share = private_poly.evaluate(&address.as_scalar());
                    let esh = EncryptedShare::new(&mut rng, address.as_bytes(), keypair.pk(), private_share).unwrap();
                    PublicShare { vk: public_share.into(), esh }
                })
                .collect::<Vec<PublicShare>>();
            shares_map.insert(*address, shares).unwrap();
        }

        shares_map
    }

    #[test]
    fn insert_shares() {
        fn default_share_vec(len: usize) -> Vec<PublicShare> {
            vec![
                PublicShare {
                    vk: G2Affine::generator().into(),
                    esh: EncryptedShare { c: Fr::zero(), u: G2Affine::generator(), v: G1Affine::generator() }
                };
                len
            ]
        }

        let n = 5;
        let mut sh_map = SharesMap::new(n);
        let mut address_bytes = [0u8; 32];
        sh_map.insert(Address::from(address_bytes), default_share_vec(n)).unwrap();
        address_bytes[0] += 1;
        sh_map.insert(Address::from(address_bytes), default_share_vec(n)).unwrap();
        assert!(sh_map.insert(Address::from(address_bytes), default_share_vec(n)).is_err(),);
        address_bytes[0] += 1;
        sh_map.insert(Address::from(address_bytes), default_share_vec(n)).unwrap();
        address_bytes[0] += 1;
        assert!(sh_map.insert(Address::from(address_bytes), default_share_vec(n + 1)).is_err(),);
        assert!(sh_map.insert(Address::from(address_bytes), default_share_vec(n - 1)).is_err());
        sh_map.insert(Address::from(address_bytes), default_share_vec(n)).unwrap();
        address_bytes[0] += 1;
        sh_map.insert(Address::from(address_bytes), default_share_vec(n)).unwrap();
        assert!(sh_map.insert(Address::from(address_bytes), default_share_vec(n)).is_err());
    }

    #[test]
    fn key_recovery_utils() {
        let test_keypair = test_keypair();
        let shares_map = build_test_map(&test_keypair);
        let participants = test_participants();
        shares_map.verify_shares(&participants).unwrap();

        let scalars = participants.keys().map(|address| address.as_scalar()).collect::<Vec<_>>();
        let interpolated_shvks = shares_map.interpolated_shvks(&scalars).unwrap();
        let expected_secrets = [Fr::from(0), Fr::from(3), Fr::from(8), Fr::from(15)];
        for (shvk, expected_secret) in interpolated_shvks.iter().zip(&expected_secrets) {
            let expected_public = G2Affine::generator() * expected_secret;
            assert_eq!(&expected_public, shvk)
        }

        #[rustfmt::skip]
        let expected_secret_evals_array = [
            [Fr::from(9), Fr::from(18), Fr::from(27), Fr::from(36)],
            [Fr::from(24), Fr::from(45), Fr::from(66), Fr::from(87)],
            [Fr::from(47), Fr::from(86), Fr::from(125), Fr::from(164)],
            [Fr::from(78), Fr::from(141), Fr::from(204), Fr::from(267)],
        ];

        for (i, (address, expected_secret_evals)) in ADDRESSES.iter().zip(&expected_secret_evals_array).enumerate() {
            let decrypted_shsks = shares_map.decrypted_shsks(i, address.as_bytes(), test_keypair.sk()).unwrap();
            assert_eq!(&decrypted_shsks, expected_secret_evals);
        }
    }

    #[test]
    fn key_recovery() {
        let expected_secrets = [Fr::from(0), Fr::from(3), Fr::from(8), Fr::from(15)];
        let test_keypair = test_keypair();
        let shares_map = build_test_map(&test_keypair);
        let participants = test_participants();
        for (address, expected_secret) in participants.keys().zip(&expected_secrets) {
            let (_gvk, share_keypair) = shares_map
                .clone()
                .recover_keys(address, test_keypair.sk(), &participants)
                .unwrap();
            assert_eq!(expected_secret, &share_keypair.sk().expose_secret());
        }
    }
}
